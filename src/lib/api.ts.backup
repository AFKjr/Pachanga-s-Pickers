import { supabase } from './supabase';
import { validatePickData } from '../utils/inputValidation';
import { handleSupabaseError, createAppError, AppError } from '../utils/errorHandling';
import type { Pick } from '../types';

// Admin verification helper function
const verifyAdminUser = async (): Promise<{ isAdmin: boolean; user: any; error?: AppError }> => {
  try {
    // Get current authenticated user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      const appError = handleSupabaseError(authError, {
        operation: 'verifyAdminUser',
        component: 'api.verifyAdminUser'
      });
      return { isAdmin: false, user: null, error: appError };
    }

    // Check if user is admin
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('is_admin')
      .eq('id', user.id)
      .single();

    if (profileError) {
      const appError = handleSupabaseError(profileError, {
        operation: 'getProfile',
        component: 'api.verifyAdminUser',
        metadata: { userId: user.id }
      });
      return { isAdmin: false, user, error: appError };
    }

    const isAdmin = profile?.is_admin || false;
    if (!isAdmin) {
      const appError = createAppError(
        new Error('Admin privileges required'),
        {
          operation: 'checkAdminPrivileges',
          component: 'api.verifyAdminUser',
          metadata: { userId: user.id }
        },
        'ADMIN_REQUIRED'
      );
      return { isAdmin: false, user, error: appError };
    }

    return { isAdmin, user };
  } catch (err) {
    const appError = createAppError(err, {
      operation: 'verifyAdminUser',
      component: 'api.verifyAdminUser'
    });
    return { isAdmin: false, user: null, error: appError };
  }
};

// Picks API
export const picksApi = {
  getAll: async () => {
    try {
      // First get all picks
      const { data: picksData, error: picksError } = await supabase
        .from('picks')
        .select('*')
        .order('created_at', { ascending: false });

      if (picksError) {
        throw handleSupabaseError(picksError, {
          operation: 'getAllPicks',
          component: 'api.getAll'
        });
      }

      // Then get profile information for each pick
      const picksWithProfiles = await Promise.all(
        (picksData || []).map(async (pick) => {
          // Skip profile fetch if user_id is null
          if (!pick.user_id) {
            return {
              ...pick,
              author_username: 'Anonymous',
              comments_count: 0
            };
          }

          const { data: profile } = await supabase
            .from('profiles')
            .select('username')
            .eq('id', pick.user_id)
            .single();

          return {
            ...pick,
            author_username: profile?.username || 'Anonymous',
            comments_count: 0 // We'll add this later if needed
          };
        })
      );

      return { data: picksWithProfiles, error: null };
    } catch (error) {
      if (error instanceof AppError) {
        return { data: null, error };
      }
      const appError = createAppError(error, {
        operation: 'getAllPicks',
        component: 'api.getAll'
      }, 'PICK_LOAD_FAILED');
      return { data: null, error: appError };
    }
  },

  getPinned: async () => {
    // First get pinned picks
    const { data: picksData, error: picksError } = await supabase
      .from('picks')
      .select('*')
      .eq('is_pinned', true)
      .order('created_at', { ascending: false });

    if (picksError) return { data: null, error: picksError };

    // Then get profile information for each pick
    const picksWithProfiles = await Promise.all(
      (picksData || []).map(async (pick) => {
        const { data: profile } = await supabase
          .from('profiles')
          .select('username')
          .eq('id', pick.user_id)
          .single();

        return {
          ...pick,
          author_username: profile?.username || 'Anonymous',
          comments_count: 0 // We'll add this later if needed
        };
      })
    );

    return { data: picksWithProfiles, error: null };
  },

  getById: async (id: string) => {
    const { data, error } = await supabase
      .from('picks')
      .select('*')
      .eq('id', id)
      .single();
    return { data, error };
  },

  create: async (pick: Omit<Pick, 'id' | 'created_at' | 'updated_at'>) => {
    try {
      // Verify admin privileges
      const { isAdmin, user, error: adminError } = await verifyAdminUser();
      if (!isAdmin) {
        const error = adminError || createAppError(
          new Error('Admin privileges required'),
          { operation: 'createPick', component: 'api.create' },
          'ADMIN_REQUIRED'
        );
        console.error('‚ùå Admin verification failed:', error);
        return { data: null, error };
      }

      console.log('‚úÖ Admin verified:', user.email);

      // Validate pick data
      const validation = validatePickData({
        homeTeam: pick.game_info.home_team,
        awayTeam: pick.game_info.away_team,
        prediction: pick.prediction,
        reasoning: pick.reasoning,
        confidence: pick.confidence as number,
        week: pick.week as number,
        gameDate: pick.game_info.game_date
      });

      if (!validation.isValid) {
        console.error('‚ùå Validation failed:', {
          errors: validation.errors,
          originalData: {
            homeTeam: pick.game_info.home_team,
            awayTeam: pick.game_info.away_team,
            prediction: pick.prediction,
            confidence: pick.confidence,
            week: pick.week,
            gameDate: pick.game_info.game_date
          }
        });
        const error = createAppError(
          new Error(`Invalid pick data: ${validation.errors.join(', ')}`),
          { 
            operation: 'createPick', 
            component: 'api.create',
            metadata: { validationErrors: validation.errors }
          },
          'VALIDATION_FAILED'
        );
        return { data: null, error };
      }

      console.log('‚úÖ Validation passed');

      // Use sanitized data for database insertion
      const sanitizedPick = {
        ...pick,
        game_info: {
          ...pick.game_info,
          home_team: validation.sanitizedData.homeTeam,
          away_team: validation.sanitizedData.awayTeam,
          game_date: validation.sanitizedData.gameDate
        },
        prediction: validation.sanitizedData.prediction,
        reasoning: validation.sanitizedData.reasoning,
        confidence: validation.sanitizedData.confidence ?? 50,
        week: validation.sanitizedData.week,
        user_id: pick.user_id || user.id,
        result: pick.result || 'pending',
        // FIX: Always provide 'pending' for ats_result and ou_result, never undefined
        ats_result: pick.ats_result || 'pending',
        ou_result: pick.ou_result || 'pending'
      };

      console.log('üìù Attempting to save pick:', {
        game: `${sanitizedPick.game_info.away_team} @ ${sanitizedPick.game_info.home_team}`,
        week: sanitizedPick.week,
        hasSpread: !!sanitizedPick.spread_prediction,
        hasOU: !!sanitizedPick.ou_prediction,
        hasMonteCarlo: !!sanitizedPick.monte_carlo_results,
        hasWeather: !!sanitizedPick.weather
      });

      const { data, error } = await supabase
        .from('picks')
        .insert([sanitizedPick])
        .select()
        .single();

      if (error) {
        console.error('‚ùå Supabase insert error:', {
          message: error.message,
          details: error.details,
          hint: error.hint,
          code: error.code
        });
        const appError = handleSupabaseError(error, {
          operation: 'createPick',
          component: 'api.create',
          metadata: { pickData: sanitizedPick }
        });
        return { data: null, error: appError };
      }

      console.log('‚úÖ Pick saved successfully:', data.id);
      return { data, error: null };
    } catch (error) {
      console.error('‚ùå Unexpected error in create:', error);
      const appError = error instanceof AppError ? error : createAppError(error, {
        operation: 'createPick',
        component: 'api.create'
      }, 'PICK_SAVE_FAILED');
      return { data: null, error: appError };
    }
  },

  update: async (id: string, updates: Partial<Pick>) => {
    try {
      // Verify admin privileges
      const { isAdmin, error: adminError } = await verifyAdminUser();
      if (!isAdmin) {
        const error = adminError || createAppError(
          new Error('Admin privileges required'),
          { operation: 'updatePick', component: 'api.update', metadata: { pickId: id } },
          'ADMIN_REQUIRED'
        );
        return { data: null, error };
      }

      const { data, error } = await supabase
        .from('picks')
        .update({ ...updates, updated_at: new Date().toISOString() })
        .eq('id', id)
        .select()
        .single();

      if (error) {
        const appError = handleSupabaseError(error, {
          operation: 'updatePick',
          component: 'api.update',
          metadata: { pickId: id, updates }
        });
        return { data: null, error: appError };
      }

      return { data, error: null };
    } catch (error) {
      const appError = error instanceof AppError ? error : createAppError(error, {
        operation: 'updatePick',
        component: 'api.update',
        metadata: { pickId: id }
      }, 'PICK_UPDATE_FAILED');
      return { data: null, error: appError };
    }
  },

  delete: async (id: string) => {
    try {
      // Verify admin privileges
      const { isAdmin, error: adminError } = await verifyAdminUser();
      if (!isAdmin) {
        const error = adminError || createAppError(
          new Error('Admin privileges required'),
          { operation: 'deletePick', component: 'api.delete', metadata: { pickId: id } },
          'ADMIN_REQUIRED'
        );
        return { error };
      }

      const { error } = await supabase
        .from('picks')
        .delete()
        .eq('id', id);

      if (error) {
        const appError = handleSupabaseError(error, {
          operation: 'deletePick',
          component: 'api.delete',
          metadata: { pickId: id }
        });
        return { error: appError };
      }

      return { error: null };
    } catch (error) {
      const appError = error instanceof AppError ? error : createAppError(error, {
        operation: 'deletePick',
        component: 'api.delete',
        metadata: { pickId: id }
      }, 'PICK_DELETE_FAILED');
      return { error: appError };
    }
  },

  subscribeToPicks: (callback: (payload: any) => void) => {
    return supabase
      .channel('picks')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'picks' }, callback)
      .subscribe();
  }
};

// Agent Statistics API
export const agentStatsApi = {
  getOverallStats: async () => {
    // Get all picks to calculate statistics
    const { data: picks, error } = await supabase
      .from('picks')
      .select('result, created_at')
      .order('created_at', { ascending: false });

    if (error) return { data: null, error };

    // Calculate statistics
    const stats = {
      totalPicks: picks?.length || 0,
      wins: picks?.filter(pick => pick.result === 'win').length || 0,
      losses: picks?.filter(pick => pick.result === 'loss').length || 0,
      pushes: picks?.filter(pick => pick.result === 'push').length || 0,
      pending: picks?.filter(pick => pick.result === 'pending').length || 0,
      winRate: 0,
      totalResolved: 0
    };

    stats.totalResolved = stats.wins + stats.losses + stats.pushes;
    // For moneyline win rate, exclude pushes since they are neither wins nor losses
    const resolvedForWinRate = stats.wins + stats.losses;
    stats.winRate = resolvedForWinRate > 0 ? (stats.wins / resolvedForWinRate) * 100 : 0;

    return { data: stats, error: null };
  },

  getRecentPerformance: async (limit: number = 10) => {
    // Get recent picks with results
    const { data: picks, error } = await supabase
      .from('picks')
      .select('result, created_at, game_info')
      .not('result', 'eq', 'pending')
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) return { data: null, error };

    return { data: picks, error: null };
  }
};

// Public Stats API - No authentication required
export const publicStatsApi = {
  getCurrentWeekStats: async () => {
    try {
      // Import dynamically to avoid circular dependencies
      const { getCurrentNFLWeek } = await import('../utils/nflWeeks');
      const { calculatePickStatistics, createEmptyStats } = await import('../services/statsCalculator');

      const currentWeek = getCurrentNFLWeek();

      // Return empty stats if no current week
      if (!currentWeek) {
        return {
          data: createEmptyStats(null),
          error: null
        };
      }

      // Fetch completed picks for current week
      const { data: picks, error } = await supabase
        .from('picks')
        .select('result, ats_result, ou_result, game_info, prediction, spread_prediction, ou_prediction')
        .eq('week', currentWeek)
        .neq('result', 'pending');

      if (error) {
        const appError = handleSupabaseError(error, {
          operation: 'getCurrentWeekStats',
          component: 'api.publicStatsApi'
        });
        return { data: null, error: appError };
      }

      // Calculate statistics using service
      const stats = await calculatePickStatistics(picks as Pick[] || [], currentWeek);

      return { data: stats, error: null };
    } catch (error) {
      const appError = createAppError(error, {
        operation: 'getCurrentWeekStats',
        component: 'api.publicStatsApi'
      }, 'PICK_LOAD_FAILED');
      return { data: null, error: appError };
    }
  },

  getAllTimeStats: async () => {
    try {
      // Import service functions
      const { calculatePickStatistics } = await import('../services/statsCalculator');

      // Fetch ALL completed picks
      const { data: picks, error } = await supabase
        .from('picks')
        .select('result, ats_result, ou_result, game_info, prediction, spread_prediction, ou_prediction')
        .neq('result', 'pending');

      if (error) {
        const appError = handleSupabaseError(error, {
          operation: 'getAllTimeStats',
          component: 'api.publicStatsApi'
        });
        return { data: null, error: appError };
      }

      // Calculate statistics using service (no week parameter for all-time)
      const stats = await calculatePickStatistics(picks as Pick[] || []);

      return { data: stats, error: null };
    } catch (error) {
      const appError = createAppError(error, {
        operation: 'getAllTimeStats',
        component: 'api.publicStatsApi'
      }, 'PICK_LOAD_FAILED');
      return { data: null, error: appError };
    }
  }
};

// Injury API - handles player injury data and impact calculations
const injuryApi = {
  // Get injury reports for a specific game date
  getByGameDate: async (gameDate: string) => {
    try {
      const { data, error } = await supabase
        .from('player_injuries')
        .select('*')
        .eq('game_date', gameDate)
        .order('team_name', { ascending: true })
        .order('position', { ascending: true });

      if (error) {
        const appError = handleSupabaseError(error, {
          operation: 'getInjuriesByGameDate',
          component: 'api.injuryApi'
        });
        return { data: null, error: appError };
      }

      return { data, error: null };
    } catch (error) {
      const appError = createAppError(error, {
        operation: 'getInjuriesByGameDate',
        component: 'api.injuryApi'
      }, 'PICK_LOAD_FAILED');
      return { data: null, error: appError };
    }
  },

  // Get injury impact for teams on a specific date
  getImpactByGameDate: async (gameDate: string) => {
    try {
      const { data, error } = await supabase
        .from('team_injury_impact')
        .select('*')
        .eq('game_date', gameDate)
        .order('team_name', { ascending: true });

      if (error) {
        const appError = handleSupabaseError(error, {
          operation: 'getInjuryImpactByGameDate',
          component: 'api.injuryApi'
        });
        return { data: null, error: appError };
    }
  },

  // Get injury data for a specific team and date range
  getTeamInjuries: async (teamName: string, startDate?: string, endDate?: string) => {
    try {
      let query = supabase
        .from('player_injuries')
        .select('*')
        .eq('team_name', teamName)
        .order('game_date', { ascending: false });

      if (startDate) {
        query = query.gte('game_date', startDate);
      }

      if (endDate) {
        query = query.lte('game_date', endDate);
      }

      const { data, error } = await query;

      if (error) {
        const appError = handleSupabaseError(error, {
          operation: 'getTeamInjuries',
          component: 'api.injuryApi'
        });
        return { data: null, error: appError };
      }

      return { data, error: null };
    } catch (error) {
      const appError = createAppError(error, {
        operation: 'getTeamInjuries',
        component: 'api.injuryApi'
      }, 'TEAM_INJURY_LOAD_FAILED');
      return { data: null, error: appError };
    }
  },

  // Calculate injury impact for a game (admin only)
  calculateGameImpact: async (homeTeam: string, awayTeam: string, gameDate: string) => {
    try {
      // Verify admin status
      const { isAdmin, error: adminError } = await verifyAdminUser();
      if (adminError || !isAdmin) {
        return { data: null, error: adminError || createAppError(new Error('Admin required'), {}, 'ADMIN_REQUIRED') };
      }

      // Get injury data for both teams
      const [homeInjuriesResult, awayInjuriesResult] = await Promise.all([
        injuryApi.getTeamInjuries(homeTeam, gameDate, gameDate),
        injuryApi.getTeamInjuries(awayTeam, gameDate, gameDate)
      ]);

      if (homeInjuriesResult.error || awayInjuriesResult.error) {
        return { data: null, error: homeInjuriesResult.error || awayInjuriesResult.error };
      }

      // Import injury calculation utilities
      const { analyzeTeamInjuryImpact, calculateAdjustedLine } = await import('../utils/injuryImpactSystem');

      // Calculate impacts
      const homeAnalysis = analyzeTeamInjuryImpact(homeInjuriesResult.data || []);
      const awayAnalysis = analyzeTeamInjuryImpact(awayInjuriesResult.data || []);

      // Mock game data for calculation (would need real odds in production)
      const mockGameData = {
        openingLine: 0, // Would need to fetch from odds API
        favoriteTeam: homeTeam, // Would need to determine from odds
        homeTeam,
        awayTeam,
        homeInjuries: homeInjuriesResult.data || [],
        awayInjuries: awayInjuriesResult.data || []
      };

      const gameAnalysis = calculateAdjustedLine(mockGameData);

      return {
        data: {
          homeTeam,
          awayTeam,
          gameDate,
          homeAnalysis,
          awayAnalysis,
          gameAnalysis
        },
        error: null
      };
    } catch (error) {
      const appError = createAppError(error, {
        operation: 'calculateGameImpact',
        component: 'api.injuryApi'
      }, 'INJURY_CALCULATION_FAILED');
      return { data: null, error: appError };
    }
  },

  // Import injury data (admin only)
  importInjuries: async (playerInjuries: any[], teamImpacts: any[]) => {
    try {
      // Verify admin status
      const { isAdmin, error: adminError } = await verifyAdminUser();
      if (adminError || !isAdmin) {
        return { data: null, error: adminError || createAppError(new Error('Admin required'), {}, 'ADMIN_REQUIRED') };
      }

      // Import player injuries
      const { data: playerData, error: playerError } = await supabase
        .from('player_injuries')
        .upsert(playerInjuries, { onConflict: 'player_name,team_name,game_date' })
        .select();

      if (playerError) {
        const appError = handleSupabaseError(playerError, {
          operation: 'importPlayerInjuries',
          component: 'api.injuryApi'
        });
        return { data: null, error: appError };
      }

      // Import team injury impacts
      const { data: impactData, error: impactError } = await supabase
        .from('team_injury_impact')
        .upsert(teamImpacts, { onConflict: 'team_name,game_date' })
        .select();

      if (impactError) {
        const appError = handleSupabaseError(impactError, {
          operation: 'importTeamInjuryImpacts',
          component: 'api.injuryApi'
        });
        return { data: null, error: appError };
      }

      return {
        data: {
          playerInjuriesImported: playerData?.length || 0,
          teamImpactsImported: impactData?.length || 0
        },
        error: null
      };
    } catch (error) {
      const appError = createAppError(error, {
        operation: 'importInjuries',
        component: 'api.injuryApi'
      }, 'INJURY_IMPORT_FAILED');
      return { data: null, error: appError };
    }
  }
};

// Simplified API export - only what you actually use
export const api = {
  picks: picksApi,
  stats: agentStatsApi,
  publicStats: publicStatsApi,
  injuries: injuryApi
};